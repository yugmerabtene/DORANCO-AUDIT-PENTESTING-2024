# DORANCO-AUDIT-PENTESTING-2024  


Prérequis :   
Virtualisation :   
**Installation de virtualbox, telechargement des logiciels prerequis pour la formation**  


Introduction (remise au point):  
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/386026c3-98ef-4334-a276-b8f288471d51)  

**Virtualisation** :
Imaginez que vous travaillez dans une grande entreprise où il y a plusieurs équipes ayant chacune besoin de serveurs pour leurs applications. Plutôt que d'acheter un serveur physique pour chaque équipe, l'entreprise utilise la virtualisation. Un seul serveur physique est installé, et à l'aide d'un logiciel de virtualisation tel que VMware ou Hyper-V, ce serveur est divisé en plusieurs machines virtuelles (VM). Chaque équipe peut alors disposer de sa propre VM avec son propre système d'exploitation et ses propres applications, tout en partageant les ressources matérielles du serveur physique.
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/2c31fc47-902b-4c8a-8274-506dbb1f88e0)

**Cloud Computing** :
Maintenant, supposez que l'entreprise décide de déplacer une partie de ses opérations vers le cloud. Plutôt que de maintenir ses propres serveurs physiques, l'entreprise décide d'utiliser les services d'un fournisseur de cloud computing, comme Amazon Web Services (AWS), Microsoft Azure ou Google Cloud Platform. L'entreprise peut alors utiliser des services tels que des serveurs virtuels (instances EC2 sur AWS), du stockage (Amazon S3), ou des bases de données (Amazon RDS), sans avoir à gérer l'infrastructure physique sous-jacente. Par exemple, au lieu de créer et de gérer des VM sur ses propres serveurs, l'entreprise peut louer des serveurs virtuels à la demande dans le cloud, en payant uniquement pour les ressources utilisées.
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/554a0ef8-d19b-4b83-935b-0ab8ae06ec18)



![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/c31974f5-cd98-4ad7-bfe8-30c2fb644356)  
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/cd92459d-a0a8-4a44-b1b0-903fcb219997)  
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/e150a633-2d42-4a3f-b8ee-0ffd722dbaf4)  
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/352deae1-91db-4869-8b94-b6b65f4ca1d3)  
 ![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/6fcacc81-4e04-4e0e-bb99-c6132667b8f4)  
 ![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/799075c8-d160-4779-9b71-1541136203e2)  

---
Cryptographie :  


La cryptographie symétrique est l'une des plus anciennes techniques cryptographiques connues de l'homme et qui offre encore aujourd'hui un haut niveau de sécurité pour faire face à différentes situations d'utilisation, et tout cela grâce à une clé secrète pour chiffrer et déchiffrer les informations. .
Parmi les premières méthodes utilisées pour le cryptage des informations figure la cryptographie symétrique. Aussi connu sous le nom la cryptographie de clé secrète ou cryptographie d'une clé. Son nom est parce que cette méthode utilise la même clé pour le chiffrement et le déchiffrement d'un message. Par conséquent, l'expéditeur et le destinataire doivent préalablement s'entendre et connaître la clé à utiliser.

Un bon exemple de ce type de système cryptographique serait le suivant:


Supposons que Maria veuille envoyer un message crypté à Jose. Les deux doivent communiquer au préalable, et se mettre d'accord sur la clé qu'ils vont utiliser. Une fois cela, María peut crypter le message et l'envoyer à José, où il est avec la même clé que María a utilisée, il peut décrypter le message.


Dans la cryptographie symétrique, toute la sécurité est centrée sur les clés. Cela doit donc être secret et difficile à deviner pour une tierce personne. Cependant, avec la technologie dont nous disposons aujourd'hui, le processus de communication ou de distribution de la clé est devenu le point faible de cette méthode. Depuis lors de la communication (l'expéditeur et le destinataire) pour définir et convenir de la clé, un tiers peut intercepter ladite communication, récupérer la clé et accéder aux informations contenues dans le message.

Mais avant de continuer à étudier ces détails, apprenons un peu l'histoire de la cryptographie symétrique.  

La crypto a été développée il y a de nombreuses années. On estime que depuis l'époque de L'Égypte ancienne et l' Empire romain la cryptographie symétrique a été utilisée de manière très basique. Cependant, il a été développé et largement utilisé au cours de la Seconde Guerre mondiale. C'est au cours de ce conflit guerrier que les armées ont utilisé et développé de puissants systèmes cryptographiques symétriques. Tout cela pour encoder les messages et les protéger des ennemis.

Après ces événements, l'ère de la cryptographie symétrique moderne a subi une révolution jusqu'à ce qu'elle atteigne ce que nous savons aujourd'hui. Tout cela grâce au travail de chercheurs et scientifiques dédiés à ce domaine. Cependant, un nom se démarque au-dessus de tous les autres, celui de Claude Shannon. Shannon est connu comme le père de la cryptographie mathématique.  

Les travaux de Shannon se sont développés à partir de 1949, lorsqu'elle a publié un article intitulé Théorie de la communication des systèmes de secret. Cet article décrit la modernisation des techniques de chiffrement connues jusqu'alors, avec des processus mathématiques avancés qui lui ont donné un niveau de complexité et de sécurité plus élevé. Plus tard, il a écrit un livre avec l'informaticien, Warren Weaver. Tout cet ensemble de travaux effectués, est devenu les bases de la cryptographie symétrique moderne.  

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/ab7fc5f1-50c5-4b3c-bb28-b9b84a504d43)


**Bref historique de son développement et de son évolution**
La première avancée notable de la cryptographie symétrique a été décrite par le troisième président des États-Unis, Thomas Jefferson entre 1790 et 1780. Cela s'appelait roue de chiffrement ou cylindre Jefferson. Il se composait d'un axe qui avait 26 cylindres rotatifs qui avaient les 26 lettres de l'alphabet gravées au hasard.

En utilisant ce curieux appareil, l'expéditeur pouvait écrire le message sur une ligne, puis en choisir une autre pour l'envoyer au destinataire. Ensuite, le récepteur avec un autre cylindre avec la même séquence de disques, a transféré la commande et a cherché la ligne qui avait du sens, déchiffrant le message. Cependant, cette méthode n'a jamais été utilisée au moment de sa création. Mais son concept était si avancé qu'il a servi de base à la cryptographie militaire américaine pendant la Première Guerre mondiale.


![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/f88278f7-905b-4e31-90b9-45027c8ea68e)


Par contre, pendant Seconde Guerre mondiale, L'Allemagne a également réalisé une autre percée dans la crypto symétrique: la création du Machine à énigme. Son fonctionnement était très similaire au cylindre Jefferson, car il utilisait des roues rotatives pour crypter un message. Ils étaient donc pratiquement impossibles à lire sans utiliser une autre machine Enigma. Bien que plus tard, les Alliés aient pu démêler et casser le cryptage de la machine en utilisant les premiers ordinateurs au monde. Ce fait a fini par donner aux Alliés un avantage certain sur le nazisme.

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/b93ff9c7-84bb-497b-84af-b6845b3bf415)


**L'Ère de l'Informatique :**

Avec l'avènement de l'informatique, les ordinateurs sont devenus des outils essentiels en cryptographie. Cependant, le cryptage et le décryptage sont devenus associés au secret et à l'espionnage, menant à des controverses telles que les CryptoWars, où des agences comme la NSA des États-Unis ont contrôlé et restreint la recherche en cryptographie. Ce blocage a duré des années, jusqu'à ce que IBM développe en 1975 l'algorithme de chiffrement DES, marquant ainsi le début de la cryptographie moderne.


**Algorithmes de Chiffrement Symétrique :**

Depuis lors, les méthodes de cryptage ont évolué. Le DES, premier algorithme informatique, a été remplacé par l'AES après des années d'analyse. L'AES est plus sûr et plus efficace, avec des clés de taille variable et un processus de cryptage en blocs.

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/e354df7f-eb46-4460-9953-3d5ba8c8edd5)


**Avantages et Inconvénients :**

Le cryptage symétrique offre rapidité et simplicité, idéal pour la protection des données dans les systèmes informatiques actuels. Cependant, il nécessite une distribution sécurisée des clés et reste vulnérable aux attaques par force brute. Malgré ses défauts, il reste largement utilisé, en combinaison avec d'autres méthodes, pour sécuriser nos communications et données sensibles.  


**Chiffrement Asymétrique :**

Le chiffrement asymétrique, aussi connu sous le nom de chiffrement à clé publique, est utilisé pour sécuriser les transactions sur des réseaux tels que Bitcoin, ainsi que pour d'autres transferts de données en ligne, comme les e-mails. Contrairement au chiffrement symétrique, il utilise deux clés distinctes pour l'expéditeur et le destinataire : une clé publique, partagée entre les participants, et une clé privée, détenue uniquement par son propriétaire. Cette méthode offre une sécurité accrue, mais nécessite davantage de ressources.


 ![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/03010bdd-be9c-469b-9366-e4b43beeec5a)  

**Fonctionnement détaillé du Chiffrement Asymétrique :**

Chaque partie d'une transaction génère une paire de clés : une clé publique, accessible à tous, et une clé privée, gardée secrète. L'expéditeur utilise la clé publique du destinataire pour chiffrer la transaction, puis signe numériquement celle-ci avec sa propre clé privée. Les mineurs valident la transaction en utilisant la clé publique, ajoutant ainsi la transaction à un bloc de la blockchain.

**Inconvénients et Solutions :**  

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/8889daa4-7a72-44e0-b8de-09f9d2d8038d)  

Bien que sécurisé, le chiffrement asymétrique est plus lent et plus intensif en calcul que le chiffrement symétrique, ce qui peut poser problème pour des données volumineuses ou nécessitant une réponse rapide. Les méthodes de chiffrement hybride combinent les avantages des deux approches, utilisant par exemple une clé de session générée de manière aléatoire pour surmonter ces limitations.


----

**TP-01:**  
### Chiffrement Symétrique en Java

Class `Main.java` :

```java
import java.util.Base64;

public class Main {

    public static void main(String[] args) throws Exception {
        // Créer une instance de la classe de chiffrement
        SymmetricEncryption symmetricEncryption = new SymmetricEncryption();

        // Le texte à chiffrer
        String plainText = "Bonjour, ceci est un message secret.";

        // Chiffrer le texte
        byte[] encryptedText = symmetricEncryption.encrypt(plainText);

        // Afficher le texte chiffré
        System.out.println("Texte chiffré : " + Base64.getEncoder().encodeToString(encryptedText));

        // Déchiffrer le texte
        String decryptedText = symmetricEncryption.decrypt(encryptedText);

        // Afficher le texte déchiffré
        System.out.println("Texte déchiffré : " + decryptedText);
    }
}
```

Class `SymmetricEncryption.java` :

```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class SymmetricEncryption {

    private SecretKey secretKey;

    public SymmetricEncryption() throws Exception {
        // Générer une clé secrète
        this.secretKey = generateSecretKey();
    }

    // Méthode pour générer une clé secrète AES
    private SecretKey generateSecretKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(128); // Taille de la clé en bits
        return keyGen.generateKey();
    }

    // Méthode pour chiffrer le texte
    public byte[] encrypt(String plainText) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);
        return cipher.doFinal(plainText.getBytes());
    }

    // Méthode pour déchiffrer le texte
    public String decrypt(byte[] cipherText) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, this.secretKey);
        byte[] decryptedBytes = cipher.doFinal(cipherText);
        return new String(decryptedBytes);
    }
}
```
**TP-02:**  
### Chiffrement Asymétrique en Java : 

```java
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;

public class KeyPairGeneratorUtil {

    // Méthode pour générer une paire de clés RSA
    public static KeyPair generateKeyPair() throws Exception {
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }
}
```

```java
import java.security.PrivateKey;
import java.security.PublicKey;
import javax.crypto.Cipher;

public class RSAEncryptionUtil {

    // Méthode pour chiffrer un message avec la clé publique RSA
    public static byte[] encrypt(String message, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", "BC");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(message.getBytes());
    }

    // Méthode pour déchiffrer un message avec la clé privée RSA
    public static String decrypt(byte[] encryptedMessage, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", "BC");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return new String(cipher.doFinal(encryptedMessage));
    }
}
```



```java
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;

public class Main {
    public static void main(String[] args) throws Exception {
        // Génération de la paire de clés RSA
        KeyPair keyPair = KeyPairGeneratorUtil.generateKeyPair();

        // Récupération de la clé publique et privée
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();

        // Message à chiffrer
        String message = "Hello, world!";

        // Chiffrement du message
        byte[] encryptedMessage = RSAEncryptionUtil.encrypt(message, publicKey);

        // Déchiffrement du message
        String decryptedMessage = RSAEncryptionUtil.decrypt(encryptedMessage, privateKey);

        // Affichage du message déchiffré
        System.out.println("Message déchiffré: " + decryptedMessage);
    }
}
```
**TP-03:**  
### Chiffrement symétrique (AES) en SHELLCODE:

#### Génération de la clé AES :

1. **Générer la clé AES** :
   ```
   openssl rand -base64 32 > aes_key.txt
   ```

#### Chiffrement et déchiffrement :

1. **Chiffrer un fichier avec AES** :
   ```
   openssl enc -aes-256-cbc -salt -in plaintext.txt -out encrypted_aes.bin -pass file:aes_key.txt
   ```

2. **Déchiffrer un fichier avec AES** :
   ```
   openssl enc -d -aes-256-cbc -in encrypted_aes.bin -out decrypted_aes.txt -pass file:aes_key.txt
   ```

Assurez-vous de remplacer `plaintext.txt` par le nom de votre fichier contenant le texte en clair. Les fichiers de clés générés sont `private_key.pem` et `public_key.pem` pour RSA, et `aes_key.txt` pour AES. Les fichiers chiffrés seront respectivement `encrypted_rsa.txt` et `decrypted_rsa.txt` pour RSA, et `encrypted_aes.bin` et `decrypted_aes.txt` pour AES.  


### Chiffrement avec openssl : 

### Chiffrement asymétrique (RSA) :

#### Génération des clés RSA :

1. **Générer la paire de clés privée/publique** :
   ```
   openssl genpkey -algorithm RSA -out private_key.pem -aes256
   ```

2. **Extraire la clé publique** :
   ```
   openssl rsa -pubout -in private_key.pem -out public_key.pem
   ```

#### Chiffrement et déchiffrement :

1. **Chiffrer un fichier avec la clé publique** :
   ```
   openssl rsautl -encrypt -pubin -inkey public_key.pem -in plaintext.txt -out encrypted_rsa.txt
   ```

2. **Déchiffrer un fichier avec la clé privée** :
   ```
   openssl rsautl -decrypt -inkey private_key.pem -in encrypted_rsa.txt -out decrypted_rsa.txt
   ```




**Chiffrement GUI :**

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/d415ce51-f7e3-491d-a62e-0c855d7c178c)  

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/9ae9ade4-59c4-4ef2-8fb3-1f4f7a17b3bb)  



**TP-04:**  
**Hashage et intégrité des données :**
![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/ec7c2ad8-29e7-48cf-9334-e476776d3f48)  

**Création d'un algo de hashage en Java utilisant l'algorithme SHA-256  :*  

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashingAlgorithm {

    public static void main(String[] args) {
        String input = "Hello, world!"; // Texte à hasher
        
        try {
            // Création d'un objet MessageDigest avec l'algorithme SHA-256
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            
            // Calcul du hash
            byte[] hashedBytes = digest.digest(input.getBytes());
            
            // Conversion du hash en format hexadécimal
            StringBuilder hexString = new StringBuilder();
            for (byte hashedByte : hashedBytes) {
                String hex = Integer.toHexString(0xff & hashedByte);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
            
            // Affichage du hash
            System.out.println("Hash SHA-256 de '" + input + "' :");
            System.out.println(hexString.toString());
            
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
}

```
### Hashage avec 7Zip, Winrar :

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/d4b68cd3-21b2-411e-aec1-a5db3c58e7e9)    

### Chiffrement symétrique de gros volumes avec mot de passe VERACRYPT  

Pour commencer, ajoutons le référentiel nécessaire et installons Veracrypt :

```bash
sudo add-apt-repository ppa:unit193/encryption -y
sudo apt install veracrypt
```

### B. Monter un volume chiffré VeraCrypt

Maintenant que nous avons généré notre volume chiffré, nous souhaitons l'utiliser. Pour ce faire, nous devons le "monter" sur un dossier vide existant. Supposons que notre répertoire /mnt soit disponible. Nous allons monter notre volume chiffré dans ce répertoire avec la commande suivante :

```bash
veracrypt /opt/volume1 /mnt
```

Pour simplifier, le premier argument est notre volume chiffré et le second est le dossier où nous le montons. Nous devrons alors fournir le mot de passe pour déchiffrer le volume, et éventuellement la keyfile associée si elle a été utilisée lors de sa création. Pour gagner du temps, si une keyfile est utilisée, vous pouvez la spécifier directement dans la commande avec l'option "-k" :

```bash
veracrypt -k keyfile /opt/volume1 /mnt
```

Une fois le volume chiffré monté, vous pouvez y accéder librement en naviguant vers le dossier /mnt. Pour vérifier que le volume est bien monté, utilisez la commande "mount", qui affichera entre autres :

```
veracrypt-linux-ligne-command-08
```

Il est également possible de monter un volume chiffré en lecture seule pour éviter toute altération accidentelle. Utilisez la commande suivante pour cela :

```bash
veracrypt -m ro /opt/volume1 /mnt
```

Avec l'option "-m ro", le volume est monté en lecture seule.

### C. Démonter un volume chiffré VeraCrypt

Une fois que vous avez terminé de travailler sur votre volume chiffré, assurez-vous de le démonter du système de fichiers actuel. Si votre volume est nommé "volume1", utilisez la commande suivante :

```bash
veracrypt -d volume1
```

Si plusieurs volumes sont montés, vous pouvez tous les démonter en même temps avec :

```bash
veracrypt -d
```

Une fois démonté, le contenu du volume reste illisible car chiffré, préservant ainsi la confidentialité des données. Utiliser un volume chiffré offre donc une sécurité supplémentaire.


![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/d7e8bb78-915e-4e2f-b166-5bf4a925313a)  




## Hashage avec openssl :*  

openssl est principalement utilisé pour se connecter de manière sécurisée à des serveurs distants via SSH (Secure Shell). Cependant, pour le hachage de fichiers, vous pouvez utiliser des outils plus appropriés comme OpenSSL. Voici comment vous pouvez utiliser OpenSSL pour hacher un fichier :

### Utilisation d'OpenSSL pour hacher un fichier :

1. **Installer OpenSSL** :
   Assurez-vous d'avoir OpenSSL installé sur votre système. Sur la plupart des distributions Linux, il est généralement installé par défaut. Sur Windows, vous pouvez le télécharger depuis le site officiel d'OpenSSL et l'installer.

2. **Générer le hachage du fichier** :
   Ouvrez un terminal ou une invite de commande et utilisez la commande suivante pour générer le hachage d'un fichier avec OpenSSL :

   ```bash
   openssl sha256 <chemin_vers_le_fichier>
   ```

   Remplacez `<chemin_vers_le_fichier>` par le chemin absolu ou relatif vers le fichier que vous souhaitez hacher. Vous pouvez également utiliser d'autres algorithmes de hachage tels que SHA-1, SHA-256, MD5, etc., en remplaçant `sha256` par l'algorithme souhaité.

   Exemple :
   ```bash
   openssl sha256 mon_fichier.txt
   ```

   Cette commande affichera le hachage SHA-256 du fichier spécifié.

3. **Vérifier l'intégrité du fichier avec son hachage** :
   Une fois que vous avez obtenu le hachage du fichier, vous pouvez le comparer à un hachage connu pour vérifier l'intégrité du fichier. Si les hachages correspondent, cela signifie que le fichier n'a pas été altéré.

### Exemple de vérification d'intégrité :

Supposons que vous avez obtenu le hachage SHA-256 `2f834bcd890071022d8d06cf6fb86d781da8c2ff9f6423f5c170f8647c4c1a4a` pour le fichier `mon_fichier.txt`.

Vous pouvez comparer ce hachage avec celui généré sur votre système pour le même fichier. Si les hachages correspondent, le fichier est intact.



#### TP-05 : 


Enoncé :

1. Installez la pile LAMP sur votre machine virtuelle Ubuntu Server et sécurisez-la.
2. Installez WordPress sur votre machine virtuelle Ubuntu Server via le terminal.
3. Créez un script en Python qui effectue une sauvegarde quotidienne en cronjob sur le répertoire FTP contenant votre application WordPress (c'est-à-dire www), ainsi que la base de données complète du serveur MySQL. Le tout doit être chiffré avec une clé symétrique pour garantir la sécurité.
4. Envoyez la sauvegarde chiffrée en FTP vers le deuxième serveur de sauvegarde, qui se trouve sur le même réseau virtuel que votre serveur web principal.

Réponses :

1. Pour installer la pile LAMP sur votre machine virtuelle Ubuntu Server et la sécuriser, vous pouvez utiliser les commandes suivantes :

```bash
sudo apt update
sudo apt install apache2
sudo apt install mysql-server
sudo apt install php libapache2-mod-php php-mysql
sudo mysql_secure_installation
```

2. Pour installer WordPress via le terminal sur votre machine virtuelle Ubuntu Server, vous pouvez suivre ces étapes :

```bash
sudo apt update
continuer a installer wordpress
```

3. le script de sauvegarde et de chiffrement :

**Installatin des dependances*
```bash
sudo apt install python3-pip
python3 -m pip install paramiko 

```


```python
import shutil
import subprocess
import os
import datetime
import paramiko

source_dir = '/var/www/'
backup_dir = '/home/yug/'
backup_name = 'wordpress_backup_' + datetime.datetime.now().strftime('%Y-%m-%d') + '.tar.gz'

print("Connecting to MySQL server")

# Backup MySQL database
mysql_user = 'yug'
mysql_password = 'doranco2024'
mysql_database = 'wordpress'

mysql_backup_file = os.path.join(backup_dir, 'mysql_backup.sql')

try:
    mysql_dump_command = f"mysqldump -u {mysql_user} -p{mysql_password} {mysql_database} > {mysql_backup_file}"
    subprocess.call(mysql_dump_command, shell=True)
    print("MySQL backup completed successfully")
except Exception as e:
    print("Error occurred while backing up MySQL:", e)

# Copy FTP content to backup directory
try:
    shutil.copytree(source_dir, os.path.join(backup_dir, 'www'))
    print("Website directory copied successfully")
except Exception as e:
    print("Error occurred while copying website directory:", e)

# Create archive including MySQL backup and website content
try:
    shutil.make_archive(backup_name.split('.')[0], 'gztar', backup_dir)
    print("Archive created successfully")
except Exception as e:
    print("Error occurred while creating archive:", e)

# Copy encryption key to backup directory
encryption_key = 'aes_key.txt'
encryption_key_backup = os.path.join(backup_dir, encryption_key)

try:
    shutil.copy(encryption_key, encryption_key_backup)
    print("Encryption key copied successfully")
except Exception as e:
    print("Error occurred while copying encryption key:", e)

# Encrypt backup file with OpenSSL
encrypted_backup_file = os.path.join(backup_dir, 'encrypted_backup.tar.gz')

try:
    openssl_encrypt_command = f"openssl enc -aes-256-cbc -salt -in {backup_name} -out {encrypted_backup_file} -pass file:{encryption_key_backup}"
    subprocess.call(openssl_encrypt_command, shell=True)
    print("Encryption completed successfully")
except Exception as e:
    print("Error occurred while encrypting backup file:", e)

# SFTP Connection details
sftp_host = '192.168.1.13'
sftp_port = 22
sftp_username = 'yug'
sftp_password = 'doranco'

# Connect to SFTP server and upload encrypted backup file and encryption key
try:
    transport = paramiko.Transport((sftp_host, sftp_port))
    transport.connect(username=sftp_username, password=sftp_password)
    sftp = paramiko.SFTPClient.from_transport(transport)
    print("Connected to SFTP server")

    sftp.put(encrypted_backup_file, os.path.basename(encrypted_backup_file))
    sftp.put(encryption_key_backup, os.path.basename(encryption_key_backup))
    print("Backup and encryption key uploaded successfully")

    sftp.close()
    transport.close()
except paramiko.AuthenticationException:
    print("Authentication failed. Please check your SFTP credentials.")
except Exception as e:
    print("Error occurred during SFTP transfer:", e)


```

1. Ouvrez votre terminal.
2. Tapez la commande suivante pour ouvrir le fichier cronjobs dans l'éditeur de texte de votre choix :

```bash
crontab -e
```

3. Ajoutez la ligne suivante à la fin du fichier pour exécuter votre script de sauvegarde Python tous les jours à minuit (assurez-vous de remplacer `/chemin/vers/backup.py` par le chemin absolu de votre script de sauvegarde Python) :

```bash
0 0 * * * /chemin/vers/backup.py
```

4. Enregistrez et fermez le fichier.


5. decrypter sur le server de sauvgarde :  
```bash
sudo openssl enc -d -aes-256-cbc -in encrypted_backup.tar.gz -out decrypted -pass file:aes_key.txt
```
```bash
tar -xzf decrypted
```

**Version améliorée du script de sauvegarde :**
```python
import shutil
import subprocess
import os
import datetime
import paramiko
import random
import string

# Répertoire source contenant les données à sauvegarder
source_dir = '/var/www/'

# Répertoire de sauvegarde où seront stockées les sauvegardes
backup_dir = '/home/yug/'

# Nom de base de l'archive de sauvegarde
backup_base_name = 'wordpress_backup_' + datetime.datetime.now().strftime('%Y-%m-%d')

# Fonction pour générer une clé de chiffrement aléatoire
def generate_encryption_key():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=16))

# Génération de la clé de chiffrement
encryption_key = generate_encryption_key()

# Chemin vers le fichier contenant la clé de chiffrement
encryption_key_file = os.path.join(backup_dir, 'encryption_key.txt')

# Écriture de la clé de chiffrement dans un fichier
with open(encryption_key_file, 'w') as key_file:
    key_file.write(encryption_key)

print("Encryption key generated successfully")

# Sauvegarde de la base de données MySQL dans un fichier SQL
mysql_user = 'yug'
mysql_password = 'doranco2024'
mysql_database = 'wordpress'

mysql_backup_file = os.path.join(backup_dir, 'mysql_backup.sql')

try:
    mysql_dump_command = f"mysqldump -u {mysql_user} -p{mysql_password} {mysql_database} > {mysql_backup_file}"
    subprocess.call(mysql_dump_command, shell=True)
    print("MySQL backup completed successfully")
except Exception as e:
    print("Error occurred while backing up MySQL:", e)

# Copie du contenu du répertoire FTP dans le répertoire de sauvegarde
try:
    shutil.copytree(source_dir, os.path.join(backup_dir, 'www'))
    print("Website directory copied successfully")
except Exception as e:
    print("Error occurred while copying website directory:", e)

# Création de l'archive contenant la sauvegarde MySQL et le contenu FTP
backup_name = f"{backup_base_name}_{datetime.datetime.now().strftime('%H-%M-%S')}.tar.gz"

try:
    shutil.make_archive(os.path.join(backup_dir, backup_name.split('.')[0]), 'gztar', backup_dir)
    print("Archive created successfully")
except Exception as e:
    print("Error occurred while creating archive:", e)

# Chiffrement de l'archive avec OpenSSL
encrypted_backup_file = os.path.join(backup_dir, f"encrypted_{backup_name}")

try:
    openssl_encrypt_command = f"openssl enc -aes-256-cbc -salt -in {backup_name} -out {encrypted_backup_file} -pass file:{encryption_key_file}"
    subprocess.call(openssl_encrypt_command, shell=True)
    print("Encryption completed successfully")
except Exception as e:
    print("Error occurred while encrypting backup file:", e)

# Détails de connexion SFTP pour le serveur distant
sftp_host = '192.168.1.13'
sftp_port = 22
sftp_username = 'yug'
sftp_password = 'doranco'

# Connexion au serveur SFTP et envoi de l'archive chiffrée et de la clé de chiffrement
try:
    transport = paramiko.Transport((sftp_host, sftp_port))
    transport.connect(username=sftp_username, password=sftp_password)
    sftp = paramiko.SFTPClient.from_transport(transport)
    print("Connected to SFTP server")

    sftp.put(encrypted_backup_file, os.path.basename(encrypted_backup_file))
    sftp.put(encryption_key_file, os.path.basename(encryption_key_file))
    print("Backup and encryption key uploaded successfully")

    sftp.close()
    transport.close()
except paramiko.AuthenticationException:
    print("Authentication failed. Please check your SFTP credentials.")
except Exception as e:
    print("Error occurred during SFTP transfer:", e)
finally:
    # Nettoyage : suppression des fichiers temporaires et des répertoires
    os.remove(encryption_key_file)
    os.remove(encrypted_backup_file)
    os.remove(mysql_backup_file)
    shutil.rmtree(os.path.join(backup_dir, 'www'))
    print("Temporary files and directories deleted successfully")
```

### Spécifications du Programme de Sauvegarde :

1. **Objectif :** Le programme effectue une sauvegarde complète d'une base de données MySQL et du contenu d'un répertoire FTP, chiffre les données sauvegardées, les transfère sur un serveur distant via SFTP, puis nettoie les fichiers temporaires locaux.

2. **Fonctionnalités :**
   - Sauvegarde de la base de données MySQL dans un fichier SQL.
   - Copie du contenu du répertoire FTP dans un répertoire de sauvegarde local.
   - Génération aléatoire d'une clé de chiffrement pour sécuriser les données.
   - Création d'une archive contenant la sauvegarde MySQL et le contenu FTP.
   - Chiffrement de l'archive avec OpenSSL en utilisant la clé de chiffrement.
   - Transfert de l'archive chiffrée et de la clé de chiffrement sur un serveur distant via SFTP.
   - Suppression des fichiers temporaires locaux après le transfert.

3. **Technologies Utilisées :**
   - Python pour l'automatisation des tâches.
   - Shell pour l'exécution de commandes système.
   - Paramiko pour la connexion et le transfert via SFTP.
   - OpenSSL pour le chiffrement des données sensibles.
   - Système de fichiers Linux pour la gestion des fichiers et répertoires.

4. **Configuration Requise :**
   - Accès à la base de données MySQL avec des privilèges de sauvegarde.
   - Accès en écriture au répertoire FTP et aux fichiers de sauvegarde.
   - Installation de Python et des modules Paramiko.
   - Disponibilité de OpenSSL pour le chiffrement des données.

5. **Utilisation :**
   - Personnalisation des chemins des répertoires et des informations d'identification dans le code.
   - Exécution du programme de sauvegarde sur le serveur où les données sont stockées.
   - Automatisation possible via des tâches planifiées ou des scripts d'automatisation.


décrypter sur le server de sauvegarde :  
```bash
 sudo openssl enc -d -aes-256-cbc -in encrypted_wordpress_backup_2024-04-25_08-37-38.tar.gz -out decrypted -pass file:encryption_key.txt
```

suggestion d'mélioration: Faire en sorte que la clé et l'archive sois dans une seule archive non chiffrée pour eviter d'ecraser la clé de chiffrement sur le server de sauvegarde.



### Module-01: Introduction aux Audits et Réglementations

#### A- Comprendre les principes généraux des audits de sécurité:

| Étapes                        | Description                                                                                                                                               |
|-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. Analyse des risques        | Identifier et évaluer les risques potentiels auxquels votre système informatique est exposé, en prenant en compte les aspects techniques, organisationnels et humains.                                           |
| 2. Tests d’intrusion            | Évaluer la résistance de votre infrastructure informatique face aux attaques potentielles afin de détecter les vulnérabilités et de mesurer la robustesse des systèmes de sécurité.                                |
| 3. Plan de continuité des activités | Prévoir des mesures spécifiques pour minimiser l'impact des interruptions sur vos activités en cas d'incident ou de défaillance, assurant ainsi la reprise rapide de vos opérations.                         |


#### 1. Stratégie de sauvegarde

La mise en place d'une stratégie efficace de sauvegarde des données critiques est essentielle pour garantir la disponibilité et la sécurité des données. Voici quelques éléments clés à prendre en compte :

##### a. Choix des solutions de sauvegarde
Des solutions comme Bacula ou Duplicity offrent des fonctionnalités avancées pour la sauvegarde des données. Bacula est une solution de sauvegarde réseau multiplateforme, tandis que Duplicity est un outil de sauvegarde incrémentielle et chiffrée.

##### b. Planification des sauvegardes
Élaborez un calendrier de sauvegarde en fonction de la criticité des données. Les données critiques doivent être sauvegardées plus fréquemment, tandis que les données moins sensibles peuvent être sauvegardées moins fréquemment.

##### c. Stockage sécurisé des sauvegardes
Assurez-vous que les sauvegardes sont stockées dans des emplacements sécurisés, à l'abri des menaces physiques et numériques telles que les incendies, les inondations et les cyberattaques.

#### 2. Plan de restauration

Un plan de restauration détaillé est crucial pour restaurer rapidement les données en cas de perte. Voici quelques points à considérer lors de l'élaboration d'un plan de restauration :

##### a. Identification des données critiques
Identifiez les données critiques qui doivent être restaurées en priorité en cas de sinistre. Cela peut inclure des bases de données, des fichiers de configuration système, ou d'autres données essentielles au fonctionnement de l'organisation.

##### b. Choix des solutions de restauration
Des solutions telles que Amanda ou Restic offrent des fonctionnalités avancées pour la restauration des données. Amanda est un système de sauvegarde réseau open-source, tandis que Restic est un outil de sauvegarde décentralisé avec prise en charge du chiffrement.

##### c. Test de la procédure de restauration
Il est essentiel de tester régulièrement la procédure de restauration pour s'assurer qu'elle fonctionne comme prévu en cas de besoin. Les tests de restauration permettent de détecter et de corriger les éventuelles lacunes dans le plan de restauration.

#### Exemple de cas concret

Supposons une entreprise utilisant Bacula pour sauvegarder ses données critiques sur des serveurs locaux. Ils ont également élaboré un plan de restauration utilisant Restic pour restaurer rapidement les données en cas de sinistre.

1. L'équipe informatique planifie des sauvegardes quotidiennes des bases de données et des fichiers critiques.
2. Les sauvegardes sont stockées sur des serveurs distants sécurisés pour éviter les risques de perte de données en cas d'incident majeur sur site.
3. Un plan de restauration détaillé est élaboré, identifiant les données critiques à restaurer en priorité et les étapes à suivre pour effectuer la restauration.
4. Des tests réguliers de la procédure de restauration sont effectués pour garantir sa fiabilité et sa rapidité en cas de besoin.
5. En cas de sinistre, l'équipe informatique utilise le plan de restauration pour restaurer rapidement les données critiques, minimisant ainsi l'impact sur les opérations commerciales.

#### B- Connaître les réglementations en matière de sécurité applicables:

#### Importance de la réglementation de la sécurité informatique :

La réglementation de la sécurité informatique revêt une importance croissante en tant que cadre nécessaire pour assurer la protection des données personnelles, la sécurité des systèmes d'information et la confiance des parties prenantes. Elle permet de réduire les risques liés aux cybermenaces et d'assurer la conformité aux normes internationales et nationales de sécurité.

#### Principales réglementations en vigueur :

1. **RGPD (Règlement Général sur la Protection des Données)** :
   Le RGPD est une réglementation de l'Union européenne qui régit la protection des données personnelles des individus de l'UE. Il impose des obligations aux organisations qui traitent des données personnelles et vise à garantir le respect de la vie privée et des droits des individus. Pour plus d'informations, consultez le site officiel du RGPD : [Site officiel RGPD](https://eur-lex.europa.eu/eli/reg/2016/679/oj)

2. **LOI "Informatique et Libertés" en France** :
   La loi française "Informatique et Libertés", également connue sous le nom de loi n°78-17 du 6 janvier 1978, encadre la collecte, le traitement et la conservation des données personnelles en France. Elle a été renforcée et adaptée pour se conformer au RGPD. Pour plus d'informations, consultez le site officiel de la CNIL : [Site officiel CNIL](https://www.cnil.fr/fr/la-loi-informatique-et-libertes)

3. **Directive NIS (Network and Information Security) de l'UE** :
   La directive NIS est une législation européenne qui vise à renforcer la cybersécurité dans l'UE en établissant des normes de sécurité minimales pour les opérateurs de services essentiels et les fournisseurs de services numériques. Elle impose également des obligations en matière de notification des incidents de sécurité. Pour plus d'informations, consultez le site officiel de l'UE : [Directive NIS](https://eur-lex.europa.eu/legal-content/FR/TXT/?uri=uriserv:OJ.L_.2016.194.

01.0001.01.FRA)

4. **LOI LPM (Loi de Programmation Militaire) en France** :
   La LOI LPM est une législation française qui renforce la sécurité des systèmes d'information sensibles et stratégiques, notamment dans le domaine de la défense. Elle vise à protéger les intérêts nationaux contre les menaces cybernétiques. Pour plus d'informations, consultez le site officiel Legifrance : [LOI LPM](https://www.legifrance.gouv.fr/affichTexte.do?cidTexte=JORFTEXT000028617073)

#### Contexte et enjeux de la sécurité informatique :

La sécurité informatique est devenue un enjeu majeur avec la numérisation croissante des entreprises et des services. Les cyberattaques peuvent avoir des conséquences graves, notamment la perte de données, les perturbations des opérations commerciales et les atteintes à la réputation. La conformité aux réglementations en matière de sécurité informatique est essentielle pour atténuer ces risques et assurer la protection des données sensibles.

#### Importance de l'ISO/IEC 27001 :

L'ISO/IEC 27001 est une norme internationale reconnue pour la gestion de la sécurité de l'information. Sa mise en œuvre aide les organisations à identifier, évaluer et traiter les risques liés à la sécurité de l'information. Elle favorise également l'amélioration continue des pratiques de sécurité et la démonstration de la conformité aux exigences réglementaires. Pour plus d'informations, consultez le site officiel de l'ISO : [Site officiel ISO 27001](https://www.iso.org/iso-27001-information-security.html)

#### Meilleures pratiques pour garantir la sécurité informatique :

Pour garantir la sécurité informatique, il est recommandé d'adopter les meilleures pratiques suivantes :

- Mettre en place des politiques de sécurité robustes et des procédures de gestion des risques.
- Former régulièrement le personnel sur la sensibilisation à la sécurité et les bonnes pratiques de protection des données.
- Mettre en œuvre des mesures de sécurité techniques telles que la cryptographie, les pare-feu et les systèmes de détection des intrusions.
- Effectuer des évaluations de sécurité régulières et des audits de conformité pour identifier les vulnérabilités et les lacunes de sécurité.

**TP-06 : Audit, Attaque et Plan de Reprise d'Activité sur un server en Production**

**Objectif :** Auditer la sécurité d'un serveur WordPress, mener un Audit, phase de reconnaissance, puis des attaques ciblées pour identifier les vulnérabilités, proposer des recommandations de sécurité conformes aux normes et élaborer un plan de reprise d'activité.

**Partie A : Audit et Reconnaissance**

1. **Analyse de l'environnement :**
   - Utilisez Nmap pour scanner les ports ouverts du serveur, conformément à la norme ISO/IEC 27001.
   - Identifiez les services et leurs versions pour évaluer les vulnérabilités potentielles.

2. **Exploration de WordPress :**
   - Utilisez WPScan pour identifier les plugins et thèmes installés sur WordPress, conformément aux meilleures pratiques de sécurité.
   - Recherchez les vulnérabilités connues dans les versions de plugins et thèmes détectés.

3. **Reconnaissance Passive :**
   - Utilisez des techniques de reconnaissance passive pour recueillir des informations sur l'entreprise et ses employés, en respectant les réglementations sur la confidentialité des données.

**Partie B : Attaque et Collecte de Données**

1. **Injection SQL :**
   - Utilisez SQLmap pour détecter et exploiter les éventuelles failles d'injection SQL dans WordPress.
   - Documentez les données sensibles récupérées et les méthodes d'injection utilisées.

2. **Crack de Mot de Passe :**
   - Utilisez des outils comme John the Ripper pour casser les mots de passe des comptes utilisateurs sur le serveur WordPress ainsi que hydra pour initier une attaque bruteforce.
   - Analysez les résultats pour évaluer la force des mots de passe et identifier les comptes vulnérables.

**Partie C : Recommandations de Sécurité**

1. **Sécurité WordPress :**
   - Installez des plugins de sécurité comme Wordfence pour renforcer la sécurité de WordPress, conformément aux recommandations de la Cybersecurity and Infrastructure Security Agency (CISA).
   - Mettez en œuvre des politiques de gestion des mises à jour pour assurer la sécurité des thèmes et plugins.

2. **Politiques de Mot de Passe :**
   - Appliquez des politiques de mot de passe conformes aux recommandations de l'ANSSI (Agence nationale de la sécurité des systèmes d'information) pour garantir la robustesse des mots de passe.

3. **Sauvegarde et Restauration :**
   - Établissez des procédures de sauvegarde régulières conformes aux exigences du RGPD et de la directive NIS.
   - Utilisez des services de sauvegarde chiffrés et conformes aux normes de sécurité pour stocker les données sensibles.

**Partie D : Plan de Reprise d'Activité**

1. **Identification des données critiques :**
   - Identifiez les données critiques hébergées sur le serveur WordPress et leur importance pour les opérations de l'entreprise, conformément au RGPD et à la LOI "Informatique et Libertés".

2. **Plan de Sauvegarde et Restauration :**
   - Développez un plan de sauvegarde détaillé conforme aux exigences du RGPD, de la directive NIS et de l'ISO/IEC 27001.
   - Incluez des procédures de restauration testées régulièrement pour assurer la disponibilité des données en cas d'incident.

3. **Procédures d'Urgence :**
   - Établissez des procédures d'urgence conformes aux réglementations en matière de notification des incidents de sécurité, telles que la directive NIS.
   - Assurez-vous que les employés sont formés et préparés à réagir efficacement en cas d'incident.

4. **Test et Mise à Jour :**
   - Planifiez des tests réguliers du plan de reprise d'activité pour garantir son efficacité, en suivant les meilleures pratiques de gestion de la continuité des activités.

----

### Module-02: Réalisation d'Audits sur Windows et Linux

#### Objectif :

Mettre en œuvre des audits de sécurité sur les systèmes d'exploitation Windows et Linux.

#### Chronologie de l'Audit :

1. **Collecte d'informations :**
   - Utilisez des outils comme Nmap pour scanner le réseau et découvrir les hôtes actifs, les services ouverts et les vulnérabilités potentielles.
   - Exemple d'outil : Nmap (Network Mapper)

2. **Analyse des vulnérabilités :**
   - Utilisez des scanners de vulnérabilités pour identifier les faiblesses dans les systèmes.
   - Exemple d'outil : OpenVAS

3. **Analyse des journaux :**
   - Examinez les journaux système pour détecter des activités suspectes ou des erreurs système.
   - Exemple d'outil : Logwatch

4. **Analyse des configurations :**
   - Vérifiez les paramètres de configuration des systèmes pour vous assurer qu'ils respectent les bonnes pratiques de sécurité.
   - Exemple d'outil : Lynis

#### Outils d'Audit de Sécurité :

1. **Nmap :**
   - Commande : `nmap -sS -p- <cible>`
   - Description : Scanner de ports réseau pour découvrir les hôtes actifs et les services ouverts.

2. **OpenVAS :**
   - Commande : `openvas-setup`
   - Description : Scanner de vulnérabilités pour identifier les faiblesses dans les systèmes.

3. **Logwatch :**
   - Commande : `logwatch --detail High`
   - Description : Outil de surveillance des journaux pour détecter des activités suspectes.

4. **Lynis :**
   - Commande : `lynis audit system`
   - Description : Outil de sécurité système pour auditer la configuration du système Linux.

#### Cas Concrets :

1. **Analyse de la configuration SSH :**
   - Objectif : Vérifier la configuration de SSH pour s'assurer qu'elle est sécurisée.
   - Outils : Lynis, Configuration files (/etc/ssh/sshd_config)
   - Étapes : Analyser les paramètres de configuration de SSH à l'aide de Lynis et vérifier les autorisations d'accès.

2. **Audit des comptes utilisateurs :**
   - Objectif : Examiner les comptes utilisateurs pour détecter des anomalies.
   - Outils : Commandes système (e.g., `getent passwd`, `getent group`)
   - Étapes : Rechercher des comptes inactifs, des privilèges excessifs, des mots de passe faibles, etc.

#### Exercice en Laboratoire :

1. **Configuration de l'audit système sur Linux :**
   - Objectif : Configurer et examiner les journaux système sur un système Linux.
   - Étapes : Utiliser la commande `auditctl` pour activer l'audit du système et examiner les journaux générés.

2. **Analyse des vulnérabilités avec OpenVAS :**
   - Objectif : Scanner un réseau ou un système pour identifier les vulnérabilités.
   - Étapes : Installer et configurer OpenVAS sur Kali Linux, scanner un réseau cible, analyser les résultats et proposer des correctifs.

3. **Configuration de Windows Security sur Windows 10 :**
   - Objectif : Configurer les paramètres de sécurité de Windows 10 à l'aide de l'outil Windows Security.
   - Étapes : Accédez à Windows Security, examinez les paramètres de protection contre les virus et les menaces, configurez les paramètres de pare-feu, etc.

#### Quelques outils d'analyse :

1. **Windows Security (anciennement Windows Defender Security Center) :**
   - C'est un outil intégré à Windows 10 qui offre une suite complète de fonctionnalités de sécurité, y compris la protection contre les virus et les menaces, le pare-feu, le contrôle de l'accès aux applications, la protection contre les rançongiciels, etc.
   - Vous pouvez l'utiliser pour analyser l'état de la sécurité de votre système, effectuer des analyses antivirus, et gérer les paramètres de sécurité.

2. **Windows Firewall with Advanced Security :**
   - Il s'agit de

 l'outil de gestion du pare-feu intégré à Windows 10, qui permet de configurer et de surveiller les règles de filtrage du trafic réseau.
   - Vous pouvez l'utiliser pour examiner les règles de pare-feu existantes, ajouter de nouvelles règles, bloquer ou autoriser des connexions réseau spécifiques, etc.

3. **Microsoft Baseline Security Analyzer (MBSA) :**
   - C'est un outil gratuit fourni par Microsoft qui permet de vérifier la conformité des systèmes Windows avec les recommandations de sécurité de Microsoft.
   - Il analyse la configuration de sécurité du système, identifie les vulnérabilités connues et fournit des recommandations pour les corriger.

4. **Sysinternals Suite :**
   - Il s'agit d'un ensemble d'outils système avancés développés par Microsoft, notamment des outils de surveillance des processus, de gestion des fichiers, de surveillance du réseau, etc.
   - Des outils tels que Process Explorer, Autoruns, TCPView peuvent être utilisés pour examiner les processus en cours d'exécution, les autorisations de démarrage automatique, les connexions réseau actives, etc.

5. **Event Viewer :**
   - C'est un outil intégré à Windows 10 qui permet d'examiner les journaux système et d'application pour détecter des activités suspectes, des erreurs système, des tentatives de connexion échouées, etc.
   - Vous pouvez l'utiliser pour examiner les événements de sécurité, les événements liés à l'authentification, les erreurs système, etc.
---

### Module-03: Audit des Mots de Passe

**Réalisation d'un audit complet des mots de passe, incluant les méthodes de vérification de la robustesse des mots de passe.**

### Introduction à l'Audit des Mots de Passe

L'audit des mots de passe est une pratique essentielle en matière de sécurité informatique. Il vise à évaluer la robustesse des mots de passe utilisés dans un système donné, que ce soit pour des comptes utilisateur, des bases de données, ou des services en ligne. Un mot de passe faible constitue une faille majeure de sécurité, car il peut être facilement deviné ou piraté, compromettant ainsi la confidentialité et l'intégrité des données.

![image](https://github.com/yugmerabtene/DORANCO-AUDIT-PENTESTING-2024/assets/3670077/0f148415-5633-41bd-a69d-4eeb80fdbb9c)  

Certification CSPN ANSSI  
LockPass est **le seul gestionnaire centralisé de mots de passe certifié par l'ANSSI.**

Nous apportons un haut niveau de confiance sur les mécanismes de chiffrement utilisés et sa robustesse générale. 

Le système de sécurisation chiffre chaque mot de passe à l’aide de la paire de clés RSA de chaque utilisateur en utilisant l’algorithme AES256.

### Méthodes de Vérification de la Robustesse des Mots de Passe

#### 1. Force Brute

La méthode la plus basique de vérification de la robustesse des mots de passe est la force brute. Elle consiste à tester toutes les combinaisons possibles de caractères jusqu'à ce que le mot de passe soit trouvé. Cependant, cette méthode est inefficace pour les mots de passe longs et complexes.

**Exemple :** Si un mot de passe est composé de 8 caractères alphanumériques (lettres majuscules et minuscules, chiffres), il y a 62^8 combinaisons possibles, ce qui est extrêmement difficile à casser en utilisant la force brute.

#### 2. Attaques par Dictionnaire

Les attaques par dictionnaire consistent à utiliser une liste de mots courants, de noms, de phrases célèbres, etc., pour tenter de deviner un mot de passe. Cette méthode est plus efficace que la force brute, car elle cible les mots de passe faibles basés sur des mots courants.

**Exemple :** Si le mot de passe est "password123", une attaque par dictionnaire le trouvera rapidement car il est très commun.

#### 3. Utilisation d'Outils d'Audit de Mots de Passe

Il existe plusieurs outils open source et gratuits pour auditer la robustesse des mots de passe. Ces outils utilisent des techniques avancées pour évaluer la force des mots de passe, détecter les faiblesses et recommander des améliorations.

**Exemples d'outils :**
- **John the Ripper :** Un puissant outil en ligne de commande pour le cassage de mots de passe.
- **Hashcat :** Un autre outil de cracking de mots de passe très populaire, capable de tirer parti du parallélisme GPU pour accélérer le processus.
- **Hydra :** Un outil de cracking de mots de passe réseau qui prend en charge de nombreux protocoles comme HTTP, FTP, SSH, etc.
- **CrackStation :** Un service en ligne qui permet de vérifier si un mot de passe a été compromis dans une fuite de données.

### Exemple concret

Supposons que vous êtes un administrateur système responsable de la sécurité d'un réseau d'entreprise. Vous devez auditer les mots de passe des utilisateurs pour vous assurer qu'ils sont suffisamment robustes.

1. Vous collectez les mots de passe stockés dans la base de données de l'entreprise.
2. Vous utilisez un outil comme John the Ripper pour auditer ces mots de passe.
3. L'outil identifie plusieurs mots de passe faibles, tels que "password123", "123456", etc.
4. Vous informez les utilisateurs concernés de la nécessité de changer leurs mots de passe pour des versions plus sécurisées.
5. Vous mettez en place des politiques de mot de passe strictes, telles que l'exigence de longueur minimale, l'utilisation de caractères spéciaux, etc.
6. Vous ré-auditez régulièrement les mots de passe pour vous assurer que les politiques sont respectées.

---

### Module-04: Techniques d'Attaque de Mots de Passe


Les mots de passe sont l'un des éléments de sécurité les plus couramment utilisés pour protéger l'accès aux systèmes informatiques, aux comptes en ligne et aux données sensibles. Cependant, la sécurité d'un mot de passe dépend de sa complexité et de sa longueur. Les techniques d'attaque de mots de passe sont des méthodes utilisées par les pirates informatiques pour tenter de contourner ces mesures de sécurité et accéder illégalement à des informations protégées. Dans ce module, nous allons examiner différentes techniques d'attaque de mots de passe et discuter des moyens de renforcer la sécurité des mots de passe.

### I. Introduction aux Techniques d'Attaque de Mots de Passe

1. **Objectif des attaques de mots de passe**:
   - Les attaques de mots de passe visent à obtenir un accès non autorisé à des systèmes informatiques, des comptes en ligne ou des données sensibles en découvrant ou en contournant les mots de passe.

2. **Types d'attaques**:
   - Force brute.
   - Attaques par dictionnaire.
   - Attaques par hachage.
   - Attaques par rejeu.
   - Attaques par ingénierie sociale.

### II. Techniques d'Attaque de Mots de Passe

1. **Force brute**:
   - Consiste à essayer toutes les combinaisons possibles de caractères jusqu'à ce que le bon mot de passe soit trouvé.
   - Très gourmand en ressources et en temps, mais efficace sur les mots de passe faibles ou courts.
   - Des outils automatisés sont souvent utilisés pour accélérer ce processus.

2. **Attaques par dictionnaire**:
   - Utilise une liste prédéfinie de mots couramment utilisés, de noms, de phrases, etc., pour tenter de deviner le mot de passe.
   - Plus rapide que la force brute, mais nécessite une bonne liste de mots pour réussir.

3. **Attaques par hachage**:
   - Implique l'utilisation de tables arc-en-ciel (rainbow tables) ou de dictionnaires de hachages précalculés pour comparer les hachages des mots de passe.
   - Utile lorsque les mots de passe sont stockés sous forme de hachage dans une base de données.

4. **Attaques par rejeu**:
   - Interceptent et rejouent des communications entre un utilisateur et un système authentifiant, souvent utilisées pour capturer les informations d'identification.

5. **Attaques par ingénierie sociale**:
   - Impliquent la manipulation psychologique des utilisateurs pour obtenir des informations d'identification.
   - Peut inclure des techniques telles que l'ingénierie sociale, le phishing, le pretexting, etc.

### III. Renforcement de la Sécurité des Mots de Passe

1. **Complexité des mots de passe**:
   - Encourager l'utilisation de mots de passe longs et complexes comprenant des lettres majuscules et minuscules, des chiffres et des caractères spéciaux.

2. **Politiques de mot de passe**:
   - Établir des politiques de mot de passe robustes, telles que l'exigence de changements de mot de passe périodiques et l'interdiction de l'utilisation de mots de passe courants ou facilement devinables.

3. **Authentification à deux facteurs (2FA)**:
   - Renforce la sécurité en exigeant une deuxième forme d'authentification, telle qu'un code envoyé par SMS ou généré par une application, en plus du mot de passe.

4. **Stockage sécurisé des mots de passe**:
   - Utilisation de techniques de hachage et de salage pour stocker les mots de passe de manière sécurisée dans les bases de données, afin de rendre plus difficile leur récupération par des attaquants.

5. **Sensibilisation à la sécurité**:
   - Former les utilisateurs sur les bonnes pratiques en matière de sécurité des mots de passe, y compris la sensibilisation aux risques d'ingénierie sociale et de partage de mots de passe.

**Exploration des différentes techniques d'attaques de mots de passe telles que Brute Force, Dictionnaire, Hybride, et Dictionnaire avec règles.**

### Module-05: Fonctions de Hashage  


Les fonctions de hachage sont des algorithmes qui prennent des données en entrée et génèrent une valeur de hachage unique qui représente ces données. Ces valeurs de hachage sont généralement de taille fixe et sont utilisées dans de nombreux domaines de l'informatique, notamment la sécurité, le stockage de données et la vérification de l'intégrité des données. Dans ce module, nous explorerons en détail les concepts liés aux fonctions de hachage, leurs utilisations et leurs implications en matière de sécurité.

### I. Introduction aux Fonctions de Hashage

1. **Définition**:
   - Une fonction de hachage est un algorithme qui prend des données en entrée et génère une empreinte numérique de taille fixe, appelée valeur de hachage.
   - Cette valeur de hachage est unique pour chaque ensemble de données en entrée, et un petit changement dans les données en entrée produit un résultat de hachage complètement différent.

2. **Propriétés des fonctions de hachage**:
   - Déterministe : Pour une même entrée, une fonction de hachage donnera toujours la même sortie.
   - Rapide à calculer : Les valeurs de hachage sont calculées rapidement, même pour de grandes quantités de données.
   - Difficile à inverser : Il est difficile de retrouver les données d'origine à partir de la valeur de hachage.
   - Sensible aux modifications : De petites modifications dans les données en entrée entraînent des valeurs de hachage totalement différentes.

### II. Utilisations des Fonctions de Hashage

1. **Stockage sécurisé des mots de passe**:
   - Plutôt que de stocker les mots de passe en clair, les systèmes stockent généralement leur hachage. Lors de l'authentification, le hachage du mot de passe fourni par l'utilisateur est comparé au hachage stocké.

2. **Intégrité des données**:
   - Les valeurs de hachage sont utilisées pour vérifier si des données ont été altérées pendant le stockage ou la transmission. Si la valeur de hachage calculée des données reçues correspond à la valeur de hachage attendue, cela indique que les données n'ont pas été modifiées.

3. **Stockage sécurisé des données**:
   - Les valeurs de hachage sont utilisées pour identifier de manière unique des enregistrements dans les bases de données, améliorant ainsi les performances des opérations de recherche.

4. **Cryptographie**:
   - Les fonctions de hachage sont utilisées dans divers protocoles de cryptographie, tels que la signature numérique et les certificats SSL/TLS.

### III. Sécurité des Fonctions de Hashage

1. **Résistance à la préimage**:
   - Il doit être difficile de trouver les données d'origine à partir de la valeur de hachage (résistance à la préimage).

2. **Résistance à la seconde préimage**:
   - Il doit être difficile de trouver une deuxième entrée qui produira la même valeur de hachage que l'entrée initiale (résistance à la seconde préimage).

3. **Résistance aux collisions**:
   - Il doit être difficile de trouver deux ensembles de données différents qui produisent la même valeur de hachage (résistance aux collisions).

### IV. Exemples de Fonctions de Hashage

1. **MD5 (Message Digest Algorithm 5)**:
   - Une fonction de hachage largement utilisée, mais considérée comme obsolète en raison de ses vulnérabilités aux attaques.

2. **SHA-1 (Secure Hash Algorithm 1)**:
   - Une autre fonction de hachage obsolète en raison de ses vulnérabilités aux attaques.

3. **SHA-256**:
   - Fait partie de la famille des algorithmes de hachage SHA-2 et est largement utilisé aujourd'hui pour la sécurité et la vérification de l'intégrité des données.

**Compréhension des fonctions de hashage utilisées dans le stockage des mots de passe et leur rôle dans la sécurité.**

### Module-06: Outils d'Attaque de Mots de Passe

Dans ce module, nous allons explorer plusieurs outils couramment utilisés pour mener des attaques de mots de passe. Ces outils sont utilisés par les professionnels de la sécurité informatique pour évaluer la robustesse des mots de passe et des mécanismes d'authentification. Voici une présentation de certains des outils les plus populaires dans ce domaine :

### I. John the Ripper

- **Description** :
  - John the Ripper est un outil de crack de mot de passe open-source.
  - Il est capable de casser des mots de passe chiffrés en utilisant différentes techniques comme la force brute et les attaques par dictionnaire.

- **Caractéristiques** :
  - Supporte de nombreux formats de hachage couramment utilisés.
  - Peut être utilisé en ligne de commande ou avec une interface graphique.

### II. Hashcat

- **Description** :
  - Hashcat est un autre outil populaire de crack de hachage, souvent considéré comme plus rapide que John the Ripper dans certains scénarios.

- **Caractéristiques** :
  - Prend en charge une vaste gamme d'algorithmes de hachage.
  - Utilise l'accélération matérielle (GPU) pour accélérer les opérations de crack de hachage.

### III. Hydra

- **Description** :
  - Hydra est un outil de force brute réseau qui prend en charge de nombreux protocoles d'authentification tels que SSH, FTP, HTTP, etc.

- **Caractéristiques** :
  - Peut mener des attaques de force brute sur plusieurs services simultanément.
  - Offre une grande flexibilité dans la configuration des attaques.

### IV. Medusa

- **Description** :
  - Medusa est similaire à Hydra et est utilisé pour mener des attaques de force brute sur différents protocoles.

- **Caractéristiques** :
  - Supporte une variété de services réseau tels que FTP, SSH, Telnet, etc.
  - Peut gérer des attaques avec plusieurs utilisateurs et mots de passe.

### V. Ophcrack

- **Description** :
  - Ophcrack est un outil spécialisé dans la récupération de mots de passe Windows en utilisant des tables arc-en-ciel (rainbow tables).

- **Caractéristiques** :
  - Facile à utiliser, même pour les débutants.
  - Fonctionne en analysant les fichiers de hachage de Windows.

### VI. Utilisation Responsable des Outils

Il est crucial de souligner que ces outils doivent être utilisés de manière éthique et légale. Ils peuvent être utilisés pour tester la sécurité des systèmes sous réserve d'autorisation appropriée. L'utilisation abusive de ces outils peut entraîner des conséquences juridiques graves.


### Module-07: Sécurisation des Mots de Passe

Ce module se concentre sur les meilleures pratiques pour sécuriser les mots de passe, élément crucial dans la protection des systèmes informatiques et des données sensibles. Nous explorerons différentes méthodes, notamment l'utilisation de techniques de hachage sécurisées, l'implémentation de politiques de mots de passe robustes et d'autres mesures de sécurité connexes.

### I. Utilisation de Méthodes de Hachage Sécurisées

1. **Choix de l'algorithme de hachage** :
   - Utiliser des algorithmes de hachage sécurisés tels que SHA-256 ou SHA-3 plutôt que des algorithmes obsolètes comme MD5 ou SHA-1.

2. **Utilisation du salage (Salt)** :
   - Ajouter une valeur aléatoire unique (sel) à chaque mot de passe avant le hachage pour rendre les attaques par dictionnaire et les tables arc-en-ciel plus difficiles à réussir.

3. **Itérations de hachage (Key stretching)** :
   - Appliquer des itérations de hachage pour augmenter le coût de calcul de chaque hachage, rendant les attaques par force brute plus coûteuses en temps et en ressources.

### II. Politiques de Mots de Passe Robustes

1. **Complexité des mots de passe** :
   - Exiger des mots de passe longs et complexes, comprenant des caractères alphanumériques, des lettres majuscules et minuscules, ainsi que des caractères spéciaux.

2. **Expiration des mots de passe** :
   - Mettre en place une politique de rotation régulière des mots de passe pour limiter la durée de vie des mots de passe et réduire les risques en cas de compromission.

3. **Historique des mots de passe** :
   - Empêcher les utilisateurs de réutiliser les anciens mots de passe en maintenant un historique des mots de passe récemment utilisés.

4. **Bloquer les tentatives de connexion infructueuses** :
   - Mettre en œuvre des mécanismes de verrouillage de compte après un certain nombre de tentatives de connexion infructueuses pour empêcher les attaques par force brute.

### III. Authentification à Deux Facteurs (2FA)

1. **Utilisation de l'authentification à deux facteurs** :
   - Encourager ou exiger l'utilisation de l'authentification à deux facteurs (2FA) pour renforcer la sécurité des comptes, même en cas de compromission du mot de passe.

2. **Méthodes d'authentification** :
   - Prendre en charge différentes méthodes d'authentification à deux facteurs telles que l'OTP (One-Time Password), les applications d'authentification, les clés de sécurité physique, etc.

### IV. Sensibilisation à la Sécurité

1. **Formation des utilisateurs** :
   - Sensibiliser les utilisateurs aux bonnes pratiques en matière de sécurité des mots de passe, notamment en évitant le partage de mots de passe, la réutilisation de mots de passe, etc.

2. **Communication sur les menaces** :
   - Informer régulièrement les utilisateurs sur les dernières menaces en matière de sécurité des mots de passe et sur les moyens de se protéger contre ces menaces.

### V. Stockage Sécurisé des Mots de Passe

1. **Hachage sécurisé des mots de passe** :
   - Utiliser des techniques de hachage sécurisées avec salage pour stocker les mots de passe dans les bases de données.

2. **Protection des données d'identification** :
   - Mettre en place des mesures de sécurité robustes pour protéger les données d'identification, y compris l'accès restreint aux bases de données et le cryptage des données sensibles.


### Module 08: Détection des Mots de Passe Faibles

Dans ce module, nous aborderons l'identification des signes révélateurs de mots de passe faibles et les techniques pour les détecter. La détection des mots de passe faibles est essentielle pour renforcer la sécurité des systèmes informatiques et prévenir les risques de compromission des comptes et des données sensibles.

### I. Signes Révélateurs de Mots de Passe Faibles

1. **Longueur Insuffisante** :
   - Les mots de passe courts sont généralement plus faciles à deviner ou à casser par force brute.

2. **Utilisation de Caractères Prévisibles** :
   - Les mots de passe contenant des séquences de caractères simples comme "123456" ou "abcdef" sont considérés comme faibles.

3. **Absence de Complexité** :
   - Les mots de passe ne contenant que des lettres minuscules ou uniquement des chiffres manquent de complexité et sont plus faciles à deviner.

4. **Utilisation de Données Personnelles** :
   - Les mots de passe basés sur des informations personnelles telles que le nom, la date de naissance, le numéro de téléphone, etc., sont considérés comme faibles car ils sont facilement devinables.

### II. Techniques de Détection des Mots de Passe Faibles

1. **Analyse de Force Brute** :
   - Utilisation d'outils automatisés pour tester la force des mots de passe en essayant différentes combinaisons de caractères.

2. **Analyse de Dictionnaire** :
   - Comparaison des mots de passe avec une liste prédéfinie de mots courants, de noms, de phrases, etc., pour détecter les correspondances.

3. **Évaluation de la Complexité** :
   - Utilisation d'algorithmes pour évaluer la complexité des mots de passe en analysant la longueur, la diversité des caractères et d'autres critères.

4. **Audit des Politiques de Mots de Passe** :
   - Examiner les politiques de mots de passe mises en place pour s'assurer qu'elles encouragent l'utilisation de mots de passe robustes.

### III. Outils de Détection des Mots de Passe Faibles

1. **zxcvbn** :
   - Un outil open-source développé par Dropbox pour évaluer la force des mots de passe en fonction de divers critères.

2. **Password Strength Meters** :
   - Des fonctionnalités intégrées dans de nombreux systèmes d'authentification en ligne qui évaluent la force des mots de passe saisis par les utilisateurs.

### IV. Actions Correctives

1. **Formation des Utilisateurs** :
   - Sensibilisation des utilisateurs aux risques associés aux mots de passe faibles et à l'importance d'utiliser des mots de passe robustes.

2. **Forcer le Changement de Mot de Passe** :
   - Mettre en place des politiques pour obliger les utilisateurs à changer les mots de passe faibles ou compromis.

3. **Renforcement des Politiques de Mots de Passe** :
   - Mettre à jour les politiques de mots de passe pour exiger des mots de passe plus longs et plus complexes.

### Module 09: Proposition de Correction suite à l'Audit

Après avoir mené un audit de sécurité des mots de passe, il est essentiel d'élaborer des recommandations et des solutions pour renforcer la sécurité des mots de passe et réduire les risques de compromission des comptes et des données sensibles. Dans ce module, nous explorerons différentes recommandations en fonction des résultats de l'audit.

### I. Évaluation des Risques

1. **Analyse des Faiblesses Actuelles** :
   - Identifier les faiblesses spécifiques dans les politiques de mots de passe, les pratiques des utilisateurs et les mécanismes d'authentification actuellement en place.

2. **Évaluation de l'Impact Potentiel** :
   - Estimer l'impact potentiel d'une compromission des mots de passe sur la sécurité globale des systèmes et des données de l'organisation.

### II. Recommandations pour Renforcer la Sécurité des Mots de Passe

1. **Mise à Jour des Politiques de Mots de Passe** :
   - Revoir et mettre à jour les politiques de mots de passe pour exiger des mots de passe plus longs, complexes et uniques.

2. **Formation des Utilisateurs** :
   - Organiser des sessions de formation pour sensibiliser les utilisateurs aux bonnes pratiques en matière de sécurité des mots de passe, y compris l'importance de ne pas partager les mots de passe et de choisir des mots de passe robustes.

3. **Mise en Place de l'Authentification à Deux Facteurs (2FA)** :
   - Déployer l'authentification à deux facteurs pour tous les comptes utilisateurs, ce qui ajoute une couche supplémentaire de sécurité même en cas de compromission du mot de passe.

4. **Renforcement des Contrôles de Sécurité** :
   - Mettre en place des contrôles de sécurité supplémentaires tels que des limites de connexion, des alertes pour les activités suspectes et des mécanismes de verrouillage de compte automatique après un certain nombre de tentatives infructueuses.

5. **Utilisation d'Outils de Gestion de Mots de Passe** :
   - Encourager l'utilisation d'outils de gestion de mots de passe sécurisés qui génèrent et stockent des mots de passe complexes de manière sécurisée.

### III. Implémentation des Solutions

1. **Planification et Déploiement** :
   - Élaborer un plan d'action détaillé pour la mise en œuvre des recommandations, en définissant des échéanciers clairs et des responsabilités spécifiques.

2. **Suivi et Évaluation** :
   - Mettre en place des mécanismes de suivi et d'évaluation pour surveiller l'efficacité des solutions mises en œuvre et apporter des ajustements si nécessaire.

3. **Communication et Sensibilisation** :
   - Communiquer de manière proactive avec les utilisateurs sur les changements apportés aux politiques de mots de passe et les sensibiliser aux nouvelles pratiques de sécurité.
